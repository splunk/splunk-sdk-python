# Copyright 2011-2014 Splunk, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"): you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

from __future__ import absolute_import

import logging
from logging.config import fileConfig
from logging.handlers import RotatingFileHandler
from logging import StreamHandler, Formatter
from os import path, getcwd, chdir
import inspect
import traceback


_name = None
_path = None

def getLogger(name=None, **kwargs):
    """Calculates the app name from the stack, based on the name of the root python script.

    :param name: Application name to use instead of the root python script
    :type name: str
    :type kwargs: dict
    :returns: The location of the logging configuration file
    """
    name = getName(name)
    configureLogging(name, **kwargs)
    logger = logging.getLogger(name)
    return logger

def getName(name=None):
    """Calculates the app name from the stack, based on the name of the root python script.

    :param name: Application name to use instead of the root python script
    :type name: str
    """
    global _name
    if name is None:
        if _name is None:
            name = inspect.stack()[-1][1]
        else:
            return _name

    # Strip ".py" from the log file name if auto-generated by a script.
    if '.py' in name:
        name = name.replace(".py", "")
        name = path.split(name)[-1]

    _name = name
    return name


def configure(name, path=None):
    """ Configure logging and return a logger and the location of its logging
    configuration file.

    This function expects:

    + A Splunk app directory structure::

        <app-root>
            bin
                ...
            default
                ...
            local
                ...

    + The current working directory is *<app-root>***/bin**.

      Splunk guarantees this. If you are running the app outside of Splunk, be
      sure to set the current working directory to *<app-root>***/bin** before
      calling.

    This function looks for a logging configuration file at each of these
    locations, loading the first, if any, logging configuration file that it
    finds::

        local/{name}.logging.conf
        default/{name}.logging.conf
        local/logging.conf
        default/logging.conf

    The current working directory is set to *<app-root>* before the logging
    configuration file is loaded. Hence, paths in the logging configuration
    file are relative to *<app-root>*. The current directory is reset before
    return.

    You may short circuit the search for a logging configuration file by
    providing an alternative file location in `configPath`. Logging configuration
    files must be in `logging.config format`_.

    #Arguments:

    :param name: Logger name
    :type name: str
    :param path: Location of an alternative logging configuration file or `None`
    :type path: str or NoneType
    :returns: A logger and the location of its logging configuration file

    .. _ConfigParser format: http://goo.gl/K6edZ8

    """

    path = configureLogging(name, path)
    logger = getLogger(name)
    return logger, path


def configureLogging(name=None, configPath=None, **kwargs):
    """ Configure logging from the Splunk configuration directory,
    and return the path to the logging configuration file if one is found.

    This function expects:

    + A Splunk app directory structure::

        <app-root>
            bin
                ...
            default
                ...
            local
                ...

    + The current working directory is *<app-root>***/bin**.

      Splunk guarantees this. If you are running the app outside of Splunk, be
      sure to set the current working directory to *<app-root>***/bin** before
      calling.

    This function looks for a logging configuration file at each of these
    locations, loading the first, if any, logging configuration file that it
    finds::

        local/{name}.logging.conf
        default/{name}.logging.conf
        local/logging.conf
        default/logging.conf

    The current working directory is set to *<app-root>* before the logging
    configuration file is loaded. Hence, paths in the logging configuration
    file are relative to *<app-root>*. The current directory is reset before
    return.

    You may short circuit the search for a logging configuration file by
    providing an alternative file location in `configPath`. Logging configuration
    files must be in `logging.config format`_.

    #Arguments:

    :param name: Application name (if None, will be calculated via getName)
    :type name: str
    :param configPath: Location of an alternative logging configuration file or `None`
    :type configPath: str or NoneType
    :param kwargs: keyword configuration. If no .conf file is found, they're passed to logger.basicConfig
    :type kwargs: dict
    :returns: The location of the logging configuration file

    .. _logging.config format: http://goo.gl/K6edZ8
    """
    app_directory = path.dirname(getcwd())
    # sys.stderr.write("INFO IPFIX app_directory %s\n" % app_directory)

    name = getName(name)
    global _path
    if configPath is None:
        if _path is not None:
            return _path
        else:
            probing_path = [
                'local/%s.logging.conf' % name,
                'default/%s.logging.conf' % name,
                'local/logging.conf',
                'default/logging.conf']
            for relative_path in probing_path:
                configuration_file = path.join(app_directory, relative_path)
                if path.exists(configuration_file):
                    configPath = configuration_file
                    _path = configPath
                    break
    elif not path.isabs(configPath):
        found = False
        for conf in 'local', 'default':
            configuration_file = path.join(app_directory, conf, configPath)
            if path.exists(configuration_file):
                configPath = configuration_file
                found = True
                break
        if not found:
            raise ValueError(
                'Logging configuration file "%s" not found in local or default directory' % configPath)
    elif not path.exists(configPath):
        raise ValueError('Logging configuration file "%s" not found')

    if configPath is not None:
        working_directory = getcwd()
        chdir(app_directory)
        try:
            configPath = path.abspath(configPath)
            fileConfig(configPath)
        finally:
            chdir(working_directory)
    else:
        logging.basicConfig(**kwargs)

    # If we're running inside splunk, then we ALWAYS log to splunk's var/log ...
    # noinspection PyBroadException
    try:
        from splunk.appserver.mrsparkle.lib.util import make_splunkhome_path
        logfile = make_splunkhome_path(["var", "log", "splunk", name + '.log'])

        # If there's no configuration for logging to file, we'll default to five 25MB log files
        handler_exists = any([True for h in logging.root.handlers if isinstance(h, RotatingFileHandler) and h.baseFilename == logfile])
        if not handler_exists:
            file_handler = RotatingFileHandler(logfile, mode='a', maxBytes=25000000, backupCount=5)
            formatter = Formatter('%(asctime)s %(levelname)s pid=%(process)d tid=%(threadName)s file=%(filename)s:%(funcName)s:%(lineno)d | %(message)s')
            file_handler.setFormatter(formatter)
            logging.root.addHandler(file_handler)
    except Exception as e:
        logging.root.addHandler(StreamHandler())
        logging.root.log(logging.ERROR, "%s: %s: %s", type(e).__name__, e, traceback.format_exc())
        pass

    # logger.propagate = False  # Prevent the log messages from being duplicated in the python.log file
    if len(logging.root.handlers) == 0:
        logging.root.addHandler(StreamHandler())

    return configPath
